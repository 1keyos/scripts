#!/bin/bash

# Copyright (c) 2010 The Chromium OS Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Performs an update of the chroot.

# Load common CrOS utilities.  Inside the chroot this file is installed in
# /usr/lib/crosutils.  Outside the chroot we find it relative to the script's
# location.
. "$(dirname $0)/common.sh" || { echo "Unable to load common.sh"; exit 1; }

# Script must run inside the chroot
assert_inside_chroot "$@"

# Do not run as root
assert_not_root_user

# Flags
DEFINE_boolean usepkg $FLAGS_TRUE \
  "Use binary packages to bootstrap."
DEFINE_boolean fast ${DEFAULT_FAST} "Call many emerges in parallel"
DEFINE_integer retries -1 \
  "On build failure, the number of times to retry."
DEFINE_integer jobs -1 \
  "How many packages to build in parallel at maximum."

# Parse command line flags
FLAGS "$@" || exit 1
eval set -- "${FLAGS_ARGV}"

# Only now can we die on error.  shflags functions leak non-zero error codes,
# so will die prematurely if 'set -e' is specified before now.
set -e

# Run version hooks as pre-update
${SCRIPTS_DIR}/run_chroot_version_hooks

PREBUILT_SETUP="/etc/make.conf.prebuilt_setup"
if [[ -n "$IGNORE_PREFLIGHT_BINHOST" ]]; then
  echo 'PORTAGE_BINHOST="$FULL_BINHOST"'
fi | sudo_clobber "$PREBUILT_SETUP"

info "Updating chroot"

EMERGE_FLAGS="-uNv --with-bdeps=y"
if [ "${FLAGS_usepkg}" -eq "${FLAGS_TRUE}" ]; then
  EMERGE_FLAGS="${EMERGE_FLAGS} --getbinpkg"

  # Only update toolchain when binpkgs are available. Toolchain rollout
  # process only takes place when the chromiumos sdk builder finishes
  # a successful build.
  EMERGE_FLAGS+=" --useoldpkg-atoms=sys-devel/binutils"
  EMERGE_FLAGS+=" --useoldpkg-atoms=sys-devel/gcc"
  EMERGE_FLAGS+=" --useoldpkg-atoms=sys-libs/glibc"
fi

if [[ "${FLAGS_jobs}" -ne -1 ]]; then
  EMERGE_FLAGS+=" --jobs=${FLAGS_jobs}"
fi

# Perform an update of hard-host-depends and world in the chroot.
EMERGE_CMD="emerge"
if [ "${FLAGS_fast}" -eq "${FLAGS_TRUE}" ]; then
  EMERGE_CMD="${GCLIENT_ROOT}/chromite/bin/parallel_emerge"
fi

# In first pass, update portage and toolchains. Lagged updates of both
# can cause serious issues later.
CHOST="$(portageq envvar CHOST)"
LATEST="$(gcc-config -l | grep "${CHOST}" | awk '{ print $2 }' | \
          sort -V | tail -n 1 )"
CURRENT="$(gcc-config -c)" || true # This fails if current profile is invalid.
eretry sudo -E ${EMERGE_CMD} ${EMERGE_FLAGS} \
    sys-devel/gcc sys-devel/binutils sys-libs/glibc sys-apps/portage
# If the latest toolchain wasn't already selected before we updated, do nothing,
# otherwise autoselect the latest. Also fix if the current profile is invalid.
if [ "${LATEST}" = "${CURRENT}" ] || ! gcc-config -c &> /dev/null; then
  LATEST="$(gcc-config -l | grep "${CHOST}" | awk '{ print $2 }' | \
            sort -V | tail -n 1 )"
  sudo gcc-config "${LATEST}"
fi

# Second pass, update everything else.
EMERGE_FLAGS+=" --deep"
eretry sudo -E ${EMERGE_CMD} ${EMERGE_FLAGS} \
    chromeos-base/hard-host-depends world

# Automatically discard all CONFIG_PROTECT'ed files. Those that are
# protected should not be overwritten until the variable is changed.
# Autodiscard is option "-9" followed by the "YES" confirmation.
printf '%s\nYES\n' -9 | sudo etc-update

# If the user still has old perl modules installed, update them.
PERL_VERSIONS=$(find /usr/lib*/perl5/vendor_perl/ -maxdepth 1 -mindepth 1 \
  -type d -printf '%P\n' | sort -u | wc -w)
if [ "$PERL_VERSIONS" -gt 1 ] ; then
  sudo /usr/sbin/perl-cleaner --all
fi
